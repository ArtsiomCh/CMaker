{
  parserClass="cmake.parsing.CMakeParser"
  parserUtilClass="cmake.parsing.CMakeParserUtil"
  psiImplUtilClass="cmake.parsing.CMakeParserUtilImpl"
 
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
 
  psiClassPrefix="CMake"
  psiImplClassSuffix="Impl"
  psiPackage="cmake.psi"
  psiImplPackage="cmake.psi.impl"
 
  elementTypeHolderClass="cmake.psi.CMakeTypes"
  elementTypeClass="cmake.psi.CMakeElementType"
  tokenTypeClass="cmake.psi.CMakeTokenType"
  
  tokens = [
    op_and='regexp:AND'
    op_or='regexp:OR'
    op_not='regexp:NOT'
    endfunction="regexp:endfunction"
    function="regexp:function"
    elseif="regexp:elseif"
    else="regexp:else"
    endif="regexp:endif"
    if="regexp:if"
    endmacro="regexp:endmacro"
    macro="regexp:macro"
    endforeach="regexp:endforeach"
    foreach="regexp:foreach"
    endwhile="regexp:endwhile"
    while="regexp:while"
    lpar='('
    rpar=')'
    number='regexp:\d+(\.\d*)?'
    bool='regexp:ON|OFF|TRUE|FALSE'
    bracket_comment = 'regexp:(\#\[=*\[)([^\]]|\n)*?(\]=*\])'
    bracket_argument = 'regexp:(\[=*\[)([^\]]|\n)*?(\]=*\])'
    line_comment='regexp:\#.*'
    var_ref='regexp:\$\{[A-Za-z_][A-Za-z0-9_-]*\}'
    escape_identity="regexp:\\\( | \\\) | \\\# | \\\" | (\\ ) | \\\\ | \\\$ | \\\@ | \\\^"
    escape_encoded="regexp:\\t|\\r|\\n"
    escape_semicolon="regexp:\\;"
    sep=';'
    quoted_argument='regexp:(")([^"]\\\n|[^"])*(")'
    identifier='regexp:[A-Za-z_][A-Za-z0-9_-]*'
  ]
  

    mixin("command_name")="cmake.psi.impl.CMakeNamedElementImpl"
    implements("command_name")="cmake.psi.CMakeNamedElement"
    methods("command_name")=[getNameIdentifier getName setName]

 }

// TODO: Optimise grammar to have less depth

 file         ::= file_element* <<eof>> { pin=1 }
 file_element ::= block                       |
                  loop                        |
                  cond                        |
                  cmd                         |
                  line_comment                |
                  bracket_comment
 private line_ending  ::=  ( line_comment | bracket_comment )? 
 
 meta compound_expr  ::= <<begin>> (cmd|cond|loop)* <<end>> { pin=1 }
 meta predicate_expr ::= <<pred>> (cmd|cond|loop)*
 meta command_expr   ::= <<cmd>> '(' arguments ')' { pin=2 }
 meta seq            ::= <<e>> (<<sep>>? <<e>>)*
 
 // Function/macro definition need to be separated
 block  ::= <<compound_expr fbegin fend>> | <<compound_expr mbegin mend>>
 fbegin ::= <<command_expr (function)>>
 fend   ::= <<command_expr (endfunction)>>
 mbegin ::= <<command_expr (macro)>>
 mend   ::= <<command_expr (endmacro)>>

 // Loops and conditions can nest
 // Loop block
 loop   ::= <<compound_expr lbegin lend>>
 lbegin ::= <<command_expr ( foreach | while )>>
 lend   ::= <<command_expr ( endforeach | endwhile )>>
 
 // Condition block
 cond             ::= if_expr 
                        (cmd|cond|loop)+
                        <<predicate_expr (elseif_expr)>>*
                        <<predicate_expr (else_expr)>>*
                      endif_expr { pin=1 }
 if_expr          ::= <<command_expr (if)>>
 elseif_expr      ::= <<command_expr (elseif)>>
 else_expr        ::= <<command_expr (else)>>
 endif_expr       ::= <<command_expr (endif)>>

 
 // Single command invocation
 cmd                 ::=  <<command_expr command_name>>
 command_name        ::=  identifier 
 
 arguments           ::=  argument? bracket_comment*  separated_argument*
 separated_argument  ::=  ( sep? argument | '(' arguments ')')


argument            ::=   bracket_argument |
                          quoted_argument  |
                          unquoted_argument|
                          var_ref
                            
 unquoted_argument   ::=  identifier
 
 
 